import os
import re
from pathlib import Path

from rich.console import Console

CONFIG_DEFAULTS = {
    "IDLE_SHUTDOWN_ENABLED": "true",
    "IDLE_SHUTDOWN_TIMEOUT_MIN": "20",
    "IDLE_SHUTDOWN_CPU_THRESHOLD": "10",
    "IDLE_SHUTDOWN_GRACE_MIN": "10",
    "INSTALL_CLAUDE_CODE": "false",
    "INSTALL_CODEX": "false",
    "INSTALL_GEMINI": "false",
}

_home_state = Path.home() / ".brr"
_cwd_state = Path(".state")

# Determine which state directory to use
if _home_state.exists():
    STATE_DIR = _home_state
elif _cwd_state.is_dir():
    Console(stderr=True).print(
        "[yellow]Warning:[/yellow] Using legacy .state/ directory. "
        f"Please move it to {_home_state}",
    )
    STATE_DIR = _cwd_state.resolve()
else:
    STATE_DIR = _home_state

KEYS_DIR = STATE_DIR / "keys"
CONFIG_PATH = STATE_DIR / "config.env"


def ensure_state_dirs():
    KEYS_DIR.mkdir(parents=True, exist_ok=True)
    os.chmod(KEYS_DIR, 0o700)


# --- config.env helpers ---


def read_config(path=None):
    """Read config.env into a dict."""
    path = path or CONFIG_PATH
    config = {}
    if not path.exists():
        return config
    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        m = re.match(r'^([A-Z0-9_]+)="(.*)"$', line)
        if m:
            config[m.group(1)] = m.group(2)
    return config


def write_config(config, path=None):
    """Write config dict as config.env."""
    path = path or CONFIG_PATH
    path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# config.env — generated by `brr configure`, edit and re-run to update",
        "",
    ]
    for key, value in config.items():
        lines.append(f'{key}="{value}"')
    path.write_text("\n".join(lines) + "\n")
    os.chmod(path, 0o600)


# --- provider helpers ---


def parse_provider(name):
    """Parse 'provider:template' syntax. Returns (provider, template_name).

    'nebius:h100' -> ('nebius', 'h100')
    'h100'        -> ('aws', 'h100')
    './custom.yaml' -> ('aws', './custom.yaml')
    """
    if ":" in name and not name.endswith(".yaml") and "/" not in name:
        provider, _, tpl = name.partition(":")
        return provider, tpl
    return "aws", name


def cluster_ssh_alias(provider, name):
    """Return SSH host alias for a cluster, e.g. 'brr-aws-h100', 'brr-nebius-h100'."""
    return f"brr-{provider}-{name}"


# --- staging helpers ---


def staging_dir_for(name, provider="aws"):
    """Return the staging directory for a cluster."""
    return STATE_DIR / "staging" / provider / name


def rendered_yaml_for(name, provider="aws"):
    """Return the rendered YAML path for a cluster."""
    return STATE_DIR / "staging" / provider / f"{name}.yaml"


# --- project helpers ---


def find_project_root(start=None):
    """Walk up from start (default: CWD) to find a directory with .brr/{provider}/ containing YAML files.

    Skips ~/.brr (the global state dir) — project .brr/ dirs live inside repos.
    Returns the project root Path, or None if not found.
    """
    current = Path(start or os.getcwd()).resolve()
    while True:
        brr_dir = current / ".brr"
        # Skip ~/.brr (global state dir, not a project)
        if (
            brr_dir.is_dir()
            and brr_dir.resolve() != STATE_DIR.resolve()
            and any(brr_dir.glob("*/*.yaml"))
        ):
            return current
        parent = current.parent
        if parent == current:
            return None
        current = parent


def find_project_providers(project_root):
    """List provider directories in .brr/ that contain templates.

    Returns sorted list of provider names (e.g. ['aws'], or ['aws', 'nebius']).
    """
    brr_dir = Path(project_root) / ".brr"
    if not brr_dir.is_dir():
        return []
    return sorted(
        entry.name
        for entry in brr_dir.iterdir()
        if entry.is_dir() and any(entry.glob("*.yaml"))
    )


def read_merged_config(project_root=None):
    """Read global config (CONFIG_DEFAULTS → ~/.brr/config.env).

    If project_root is None, attempts to find it via find_project_root().
    Returns (merged_config, project_root_or_None).
    """
    config = dict(CONFIG_DEFAULTS)
    config.update(read_config())
    if project_root is None:
        project_root = find_project_root()
    return config, project_root


# --- provider configuration checks ---


_REQUIRED_KEYS = {
    "aws": ["AWS_REGION", "AWS_KEY_NAME", "AWS_SECURITY_GROUP"],
    "nebius": ["NEBIUS_PROJECT_ID", "NEBIUS_SUBNET_ID", "NEBIUS_SSH_KEY"],
}


def is_provider_configured(provider, config=None):
    """Check if a provider has been configured (all required keys present)."""
    if config is None:
        config = read_config()
    required = _REQUIRED_KEYS.get(provider, [])
    return all(k in config for k in required)


def check_provider_configured(provider, config=None):
    """Raise click.UsageError if provider is not configured."""
    if is_provider_configured(provider, config):
        return
    import click

    raise click.UsageError(
        f"{provider} is not configured. Run `brr configure` or `brr init {provider}` first."
    )
